<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cow Configurator (Web Serial)</title>
  <meta name="cow-configurator-version" content="v1.3.1">
  <style>
/* Sakura Dark CSS - Inlined for offline use */
/* $color-text: #dedce5; */
/* Sakura.css v1.5.1
 * ================
 * Minimal css theme.
 * Project: https://github.com/oxalorg/sakura/
 */
/* Body */
html {
  font-size: 62.5%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
}
body {
  font-size: 1.8rem;
  line-height: 1.618;
  max-width: 38em;
  margin: auto;
  color: #c9c9c9;
  background-color: #222222;
  padding: 13px;
}
@media (max-width: 684px) {
  body {
    font-size: 1.53rem;
  }
}
@media (max-width: 382px) {
  body {
    font-size: 1.35rem;
  }
}
h1, h2, h3, h4, h5, h6 {
  line-height: 1.1;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
  font-weight: 700;
  margin-top: 3rem;
  margin-bottom: 1.5rem;
  overflow-wrap: break-word;
  word-wrap: break-word;
  -ms-word-break: break-all;
  word-break: break-word;
}
h1 {
  font-size: 2.35em;
}
h2 {
  font-size: 2em;
}
h3 {
  font-size: 1.75em;
}
h4 {
  font-size: 1.5em;
}
h5 {
  font-size: 1.25em;
}
h6 {
  font-size: 1em;
}
p {
  margin-top: 0px;
  margin-bottom: 2.5rem;
}
small, sub, sup {
  font-size: 75%;
}
hr {
  border-color: #ffffff;
}
a {
  text-decoration: none;
  color: #ffffff;
}
a:visited {
  color: #e6e6e6;
}
a:hover {
  color: #c9c9c9;
  border-bottom: 2px solid #c9c9c9;
}
ul {
  padding-left: 1.4em;
  margin-top: 0px;
  margin-bottom: 2.5rem;
}
li {
  margin-bottom: 0.4em;
}
blockquote {
  margin-left: 0px;
  margin-right: 0px;
  padding-left: 1em;
  padding-top: 0.8em;
  padding-bottom: 0.8em;
  padding-right: 0.8em;
  border-left: 5px solid #ffffff;
  margin-bottom: 2.5rem;
  background-color: #4a4a4a;
}
blockquote p {
  margin-bottom: 0;
}
img, video {
  height: auto;
  max-width: 100%;
  margin-top: 0px;
  margin-bottom: 2.5rem;
}
/* Pre and Code */
pre {
  background-color: #4a4a4a;
  display: block;
  padding: 1em;
  overflow-x: auto;
  margin-top: 0px;
  margin-bottom: 2.5rem;
  font-size: 0.9em;
}
code, kbd, samp {
  font-size: 0.9em;
  padding: 0 0.5em;
  background-color: #4a4a4a;
  white-space: pre-wrap;
}
pre > code {
  padding: 0;
  background-color: transparent;
  white-space: pre;
  font-size: 1em;
}
/* Tables */
table {
  text-align: justify;
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 2rem;
}
td, th {
  padding: 0.5em;
  border-bottom: 1px solid #4a4a4a;
}
/* Buttons, forms and input */
input, textarea {
  border: 1px solid #c9c9c9;
}
input:focus, textarea:focus {
  border: 1px solid #ffffff;
}
textarea {
  width: 100%;
}
.button, button,
input[type=submit],
input[type=reset],
input[type=button],
input[type=file]::file-selector-button {
  display: inline-block;
  padding: 5px 10px;
  text-align: center;
  text-decoration: none;
  white-space: nowrap;
  background-color: #ffffff;
  color: #222222;
  border-radius: 1px;
  border: 1px solid #ffffff;
  cursor: pointer;
  box-sizing: border-box;
}
.button:hover, button:hover,
input[type=submit]:hover,
input[type=reset]:hover,
input[type=button]:hover,
input[type=file]::file-selector-button:hover {
  background-color: #c9c9c9;
  color: #222222;
  outline: 0;
}
.button[disabled], button[disabled],
input[type=submit][disabled],
input[type=reset][disabled],
input[type=button][disabled],
input[type=file][disabled] {
  cursor: default;
  opacity: 0.5;
}
.button:focus-visible, button:focus-visible,
input[type=submit]:focus-visible,
input[type=reset]:focus-visible,
input[type=button]:focus-visible,
input[type=file]:focus-visible {
  outline-style: solid;
  outline-width: 2px;
}
textarea, select, input {
  color: #c9c9c9;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  margin-bottom: 10px;
  background-color: #4a4a4a;
  border: 1px solid #4a4a4a;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box;
}
textarea:focus, select:focus, input:focus {
  border: 1px solid #ffffff;
  outline: 0;
}
input[type=checkbox]:focus {
  outline: 1px dotted #ffffff;
}
label, legend, fieldset {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
}
  </style>
</head>
<body>
  <div class="container">
    <h2>Cow USB Configurator</h2>
    <div class="row">
      <button id="connectBtn">Connect</button>
    </div>
    <div class="version" id="versionLabel">Version: Not connected</div>
    <form id="configForm" autocomplete="off">
      <div class="row" style="display:flex; align-items:center; gap: 1em;">
        <label for="presetSelect" style="flex: 1 0 140px;">Configuration Preset</label>
        <select id="presetSelect" style="flex: 2 0 180px; width: calc(100% - 8px); margin-left: 8px;"></select>
      </div>
  <div class="row" style="display:flex; align-items:center; gap: .5em; margin-top: 0.25em;">
        <span style="flex: 1 0 140px;"></span>
        <button type="button" id="applyPresetBtn" title="Apply the selected preset">Apply</button>
        <button type="button" id="savePresetBtn" title="Save current form values as a new preset">Save as Preset</button>
        <button type="button" id="deletePresetBtn" title="Delete the selected custom preset">Delete Preset</button>
      </div>
      <div class="row" style="display: flex; align-items: flex-start; gap: 0em; flex-direction: column;">
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="address_3" style="flex: 1 0 140px; text-align: left;">address</label>
            <div id="addressBox" style="display: flex; gap: 0.5em; flex: 2 0 180px; align-items: center; width: 100%; white-space: nowrap;">
                <input id="address_0" type="number" min="0" value="67" style="display:none;" title="Address byte 1 (fixed)">
                <input id="address_1" type="number" min="0" value="79" style="display:none;" title="Address byte 2 (fixed)">
                <input id="address_2" type="number" min="0" value="87" style="display:none;" title="Address byte 3 (fixed)">
                <input id="address_3" type="number" min="0" value="0" style="width:4em; min-width:2em;" title="Address byte 4 (configurable)">
                <input id="address_4" type="number" min="0" value="0" style="width:4em; min-width:2em;" title="Address byte 5 (configurable)">
                <span id="addressMatchLabel" style="left:0.em; color:#4caf50; font-size:1em; font-weight:600; padding:0 0.2em;"></span>
          </div>
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="max_drive" style="flex: 1 0 140px;">Max Drive</label>
          <input id="max_drive" type="number" min="0" value="1000" style="flex: 2 0 180px;" title="Maximum drive speed (0-1000)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="max_turn" style="flex: 1 0 140px;">Max Turn</label>
          <input id="max_turn" type="number" min="0" value="500" style="flex: 2 0 180px;" title="Maximum turning speed (0-1000)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="max_cow" style="flex: 1 0 140px;">Max Cow</label>
          <input id="max_cow" type="number" min="0" value="500" style="flex: 2 0 180px;" title="Maximum cow factor (0-1000)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="accel" style="flex: 1 0 140px;">Acceleration</label>
          <input id="accel" type="number" step="0.01" value="0.06" style="flex: 2 0 180px;" title="Acceleration rate (0-1)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="deccel" style="flex: 1 0 140px;">Deceleration</label>
          <input id="deccel" type="number" step="0.01" value="0.04" style="flex: 2 0 180px;" title="Deceleration rate (0-1)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="cow_factor" style="flex: 1 0 140px;">Cow Factor</label>
          <input id="cow_factor" type="number" step="0.01" value="0.25" style="flex: 2 0 180px;" title="Cow factor (0-1, affects movement)">
        </div>
        <!-- New Sonar Distance setting -->
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="max_sonar_distance" style="flex: 1 0 140px;">Sonar Distance</label>
          <input id="max_sonar_distance" type="number" min="0" value="0" style="flex: 2 0 180px;" title="Maximum sonar distance (280-3000)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="working_hour" style="flex: 1 0 140px;">Hour Meter</label>
          <input id="working_hour" class="readonly" type="text" readonly value="0.00 h" style="flex: 2 0 180px;" title="Total working hours (read-only)">
        </div>
        <div style="display: flex; align-items: center; width: 100%; gap: 1em;">
          <label for="time_out" style="flex: 1 0 140px;">Fail Safe</label>
          <input id="time_out" type="number" min="0" value="2000" style="flex: 2 0 180px;" title="Timeout in milliseconds (e.g. 2000 = 2 seconds)">
        </div>
      </div>
      <div class="btn-row">
        <button type="button" id="saveBtn">Upload to Board</button>
        <button type="button" id="loadBtn">Load from Board</button>
        <button type="button" id="resetBtn">Default Reset</button>
      </div>
      <div class="btn-row">
        <button type="button" id="exportBtn">Save Config to PC</button>
        <button type="button" id="importBtn">Load Confiig from PC</button>
      </div>
    </form>
    <div id="msg"></div>
    <div id="browserWarning" style="display:none; color: #ff9800; font-weight: bold; margin-bottom: 1em;"></div>
    <div id="offlineRow" style="position: fixed; bottom: 24px; right: 32px; z-index: 1000; display: flex; align-items: center; gap: 1em; margin-bottom: 0;">
      <button id="openFlasherBtn" type="button" style="display:none;">Open Flasher</button>
      <button id="downloadOfflineBtn" type="button">Download for Offline Use</button>
      <span id="offlineLabel" style="display:none; color: #4caf50; font-weight: bold;">Working Offline</span>
      <button id="checkUpdateBtn" type="button" style="display:none;">Check for Update</button>
    </div>
    <div id="versionFooter" style="position: fixed; bottom: 16px; left: 24px; color: #aaa; font-size: 1.1em; z-index: 1000;">Version:</div>
  </div>
  <input type="file" id="importFile" accept=".json" style="display:none">
  <p style="margin-top:1em; color:#4caf50; background:#222; padding:1.1em; border-radius:6px;">
    <strong>Note:</strong> For quick setup, use these address values:<br>
    <b>Cow 1 address:</b> <code id="cow1_addr">65 68</code>
    <button type="button" style="margin-left:0.7em;" onclick="setAddress([67,79,87,65,68])">Use</button><br>
    <b>Cow 2 address:</b> <code id="cow2_addr">51 49</code>
    <button type="button" style="margin-left:0.7em;" onclick="setAddress([67,79,87,51,49])">Use</button>
  </p>
  <p style="margin-top:1em; color:#ff9800; background:#333; padding:1em; border-radius:6px;">
    <strong>Having trouble connecting or with USB drivers?</strong><br>
    You can use <a href="https://zadig.akeo.ie/#google_vignette" target="_blank" style="color:#ffd700; text-decoration:underline;">Zadig</a> to install or update your USB drivers. Visit the Zadig website for more information and downloads.<br>
    
  </p>
  <script>
    // --- Preset configuration system ---
    // Contract:
    // - Preset object shape matches "fields" ids (strings), e.g. { address_0: "67", max_drive: "800", ... }
    // - Built-in presets are read-only; custom presets are stored in localStorage under key COW_PRESETS_V1
    // - UI: <select id="presetSelect"> with option values preset ids, and buttons Apply/Save/Delete

    const PRESET_STORAGE_KEY = 'COW_PRESETS_V1';
    const BUILTIN_PRESETS = {
      'product_default': {
        label: 'Cow Product Default',
        values: {
          address_0: '67', address_1: '79', address_2: '87', address_3: '65', address_4: '68',
          max_drive: '1000', max_turn: '1000', max_cow: '500',
          accel: '0.04', deccel: '0.07', cow_factor: '0.25', time_out: '2000', max_sonar_distance: '1000'
        }
      },
      'cow_horse_product': {
        label: 'Cow Horse Product',
        values: {
          address_0: '67', address_1: '79', address_2: '87', address_3: '65', address_4: '68',
          max_drive: '1000', max_turn: '750', max_cow: '500',
          accel: '0.05', deccel: '0.06', cow_factor: '0.25', time_out: '2000', max_sonar_distance: '1000'
        }
      },
      'cow_retrofit': {
        label: 'Cow Retrofit',
        values: {
          address_0: '67', address_1: '79', address_2: '87', address_3: '65', address_4: '68',
          max_drive: '1000', max_turn: '1000', max_cow: '800',
          accel: '0.06', deccel: '0.04', cow_factor: '0.75', time_out: '2000', max_sonar_distance: '1000'
        }
      }
    };

    function loadCustomPresets() {
      try {
        const raw = localStorage.getItem(PRESET_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return typeof parsed === 'object' && parsed ? parsed : {};
      } catch { return {}; }
    }

    function saveCustomPresets(presets) {
      try { localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets)); } catch {}
    }

    function populatePresetSelect() {
      const select = document.getElementById('presetSelect');
      if (!select) return;
      select.innerHTML = '';
      // Group: Built-in
      const optGroupBuiltIn = document.createElement('optgroup');
      optGroupBuiltIn.label = 'Built-in';
      Object.entries(BUILTIN_PRESETS).forEach(([id, p]) => {
        const opt = document.createElement('option');
        opt.value = `builtin:${id}`;
        opt.textContent = p.label;
        optGroupBuiltIn.appendChild(opt);
      });
      select.appendChild(optGroupBuiltIn);
      // Group: Custom
      const custom = loadCustomPresets();
      const customIds = Object.keys(custom);
      const optGroupCustom = document.createElement('optgroup');
      optGroupCustom.label = 'Custom';
      if (customIds.length === 0) {
        const opt = document.createElement('option');
        opt.value = 'custom:__none__';
        opt.disabled = true;
        opt.textContent = 'No custom presets';
        optGroupCustom.appendChild(opt);
      } else {
        customIds.forEach(id => {
          const opt = document.createElement('option');
          opt.value = `custom:${id}`;
          opt.textContent = custom[id].label || id;
          optGroupCustom.appendChild(opt);
        });
      }
      select.appendChild(optGroupCustom);
      // Default selection to first built-in
      select.value = select.querySelector('optgroup[label="Built-in"] option')?.value || '';
    }

    function applyPresetValues(values) {
      if (!values) return;
      const ids = [
        'address_0','address_1','address_2','address_3','address_4',
        'max_drive','max_turn','max_cow','accel','deccel','cow_factor','time_out'
      ];
      ids.forEach(id => {
        if (values[id] !== undefined) {
          const el = document.getElementById(id);
          if (el) el.value = values[id];
        }
      });
      updateAddressMatchLabel?.();
    }

    function getCurrentFormValues() {
      const ids = [
        'address_0','address_1','address_2','address_3','address_4',
        'max_drive','max_turn','max_cow','accel','deccel','cow_factor','time_out'
      ];
      const data = {};
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) data[id] = String(el.value);
      });
      return data;
    }

    function onApplyPreset() {
      const select = document.getElementById('presetSelect');
      if (!select || !select.value) return;
      const [scope, id] = select.value.split(':');
      if (scope === 'builtin') {
        applyPresetValues(BUILTIN_PRESETS[id]?.values);
        showMsg('Preset applied: ' + (BUILTIN_PRESETS[id]?.label || id), 'success');
      } else if (scope === 'custom') {
        const custom = loadCustomPresets();
        applyPresetValues(custom[id]?.values);
        showMsg('Preset applied: ' + (custom[id]?.label || id), 'success');
      }
    }

    function onSavePreset() {
      const name = prompt('Name for this preset:');
      if (!name) return;
      const safeId = name.trim().toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_\-]/g, '');
      if (!safeId) { showMsg('Invalid preset name.', 'error'); return; }
      const custom = loadCustomPresets();
      custom[safeId] = { label: name.trim(), values: getCurrentFormValues() };
      saveCustomPresets(custom);
      populatePresetSelect();
      // Select the newly saved preset
      const select = document.getElementById('presetSelect');
      select.value = `custom:${safeId}`;
      showMsg('Preset saved: ' + name.trim(), 'success');
    }

    function onDeletePreset() {
      const select = document.getElementById('presetSelect');
      if (!select || !select.value) return;
      const [scope, id] = select.value.split(':');
      if (scope !== 'custom') { showMsg('Only custom presets can be deleted.', 'error'); return; }
      const custom = loadCustomPresets();
      if (!custom[id]) { showMsg('Preset not found.', 'error'); return; }
      if (!confirm(`Delete preset "${custom[id].label || id}"?`)) return;
      delete custom[id];
      saveCustomPresets(custom);
      populatePresetSelect();
      showMsg('Preset deleted.', 'success');
    }

    function wirePresetUI() {
      const applyBtn = document.getElementById('applyPresetBtn');
      const saveBtn = document.getElementById('savePresetBtn');
      const delBtn = document.getElementById('deletePresetBtn');
      if (applyBtn) applyBtn.onclick = onApplyPreset;
      if (saveBtn) saveBtn.onclick = onSavePreset;
      if (delBtn) delBtn.onclick = onDeletePreset;
      populatePresetSelect();
    }

    // Helper to set address fields from quick setup buttons
    function setAddress(arr) {
      for (let i = 0; i < 5; ++i) {
        const el = document.getElementById('address_' + i);
        if (el) el.value = arr[i];
      }
      updateAddressMatchLabel();
    }

    function updateAddressMatchLabel() {
      const cow1 = [67,79,87,65,68];
      const cow2 = [67,79,87,51,49];
      let addr = [];
      for (let i = 0; i < 5; ++i) {
        const el = document.getElementById('address_' + i);
        addr.push(parseInt(el.value, 10));
      }
      const label = document.getElementById('addressMatchLabel');
      if (addr.every((v,i)=>v===cow1[i])) {
        label.textContent = 'Cow 1';
        label.style.color = '#4caf50';
      } else if (addr.every((v,i)=>v===cow2[i])) {
        label.textContent = 'Cow 2';
        label.style.color = '#ff9800';
      } else {
        label.textContent = '';
      }
    }

    // Attach input listeners to address fields
    window.addEventListener('DOMContentLoaded', function() {
      // Set default values for hidden address fields
      document.getElementById('address_0').value = 67;
      document.getElementById('address_1').value = 79;
      document.getElementById('address_2').value = 87;
      
      for (let i = 0; i < 5; ++i) {
        const el = document.getElementById('address_' + i);
        if (el) el.addEventListener('input', updateAddressMatchLabel);
      }
      updateAddressMatchLabel();
    });
    // --- Web Serial API helpers ---
    let port = null;
    let reader = null;
    let writer = null;
    let connected = false;

    const connectBtn = document.getElementById('connectBtn');
    const versionLabel = document.getElementById('versionLabel');
    const msgDiv = document.getElementById('msg');
    const workingHourInput = document.getElementById('working_hour');
    const downloadOfflineBtn = document.getElementById('downloadOfflineBtn');
    const offlineLabel = document.getElementById('offlineLabel');
    const checkUpdateBtn = document.getElementById('checkUpdateBtn');
    const openFlasherBtn = document.getElementById('openFlasherBtn');

    const fields = [
      'address_0','address_1','address_2','address_3','address_4',
      'max_drive','max_turn','max_cow','accel','deccel','cow_factor','max_sonar_distance','working_hour','time_out'
    ];

    connectBtn.onclick = async () => {
      if (!connected) {
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          writer = port.writable.getWriter();
          reader = port.readable.getReader();
          connected = true;
          connectBtn.textContent = 'Disconnect';
          versionLabel.textContent = 'Version: Connecting...';
          showMsg('Connected to serial port.', 'success');
          openFlasherBtn.style.display = '';
          // Identify device
          const lines = await sendCmd('IDENTIFY', true);
          if (lines.length && lines[0].startsWith('COW_ROBOT_V')) {
            versionLabel.textContent = 'Version: ' + lines[0];
            showMsg('Device identified.', 'success');
            await loadFromDevice();
          } else {
            versionLabel.textContent = 'Version: Not connected';
            showMsg('Wrong device or no response.', 'error');
            openFlasherBtn.style.display = 'none';
            await disconnectSerial();
          }
        } catch (e) {
          showMsg('Connection error: ' + e, 'error');
          openFlasherBtn.style.display = 'none';
          await disconnectSerial();
        }
      } else {
        await disconnectSerial();
      }
    };

    async function disconnectSerial() {
      if (reader) { try { await reader.cancel(); } catch {} reader = null; }
      if (writer) { try { writer.releaseLock(); } catch {} writer = null; }
      if (port) { try { await port.close(); } catch {} port = null; }
      connected = false;
      connectBtn.textContent = 'Connect';
      versionLabel.textContent = 'Version: Not connected';
      showMsg('Disconnected.', 'success');
      openFlasherBtn.style.display = 'none';
      // Reset all input values to 0 on disconnect (except working_hour and fixed address bytes)
      const inputFields = [
        'address_3','address_4',
        'max_drive','max_turn','max_cow','accel','deccel','cow_factor','max_sonar_distance','time_out'
      ];
      inputFields.forEach(f => {
        const el = document.getElementById(f);
        if (el) el.value = 0;
      });
      // Keep the fixed address values
      document.getElementById('address_0').value = 67;
      document.getElementById('address_1').value = 79;
      document.getElementById('address_2').value = 87;
      const workingHourInput = document.getElementById('working_hour');
      if (workingHourInput) workingHourInput.value = '0.00 h';
    }

    async function sendCmd(cmd, waitResponse=false) {
      if (!connected || !writer) { showMsg('Not connected to serial.', 'error'); return []; }
      const framed = `@${cmd};\r\n`;
      await writer.write(new TextEncoder().encode(framed));
      await delay(100); // Add delay after every command
      if (!waitResponse) return [];
      // Read lines until timeout or empty line
      let lines = [];
      let timeout = 1000; // ms
      let start = Date.now();
      let buffer = '';
      while (Date.now() - start < timeout) {
        try {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += new TextDecoder().decode(value);
          let idx;
          while ((idx = buffer.indexOf('\n')) !== -1) {
            let line = buffer.slice(0, idx).replace(/\r/g, '').trim();
            buffer = buffer.slice(idx+1);
            if (line) lines.push(line);
          }
          if (lines.length > 0 && buffer === '') break;
        } catch (e) { break; }
      }
      return lines;
    }

    async function loadFromDevice() {
      if (!connected) { showMsg('Not connected.', 'error'); return; }
      await sendCmd('LOAD');
      const lines = await sendCmd('DUMP', true);
      if (!lines.length) { showMsg('No response from device.', 'error'); return; }
      lines.forEach(line => {
        if (line.startsWith('ADDR=')) {
          const addr = line.split('=')[1].split(':');
          for (let i=0; i<5; ++i) document.getElementById(`address_${i}`).value = parseInt(addr[i], 16);
        } else if (line.includes('=')) {
          let [key, value] = line.split('=', 2);
          key = key.toLowerCase();
          if (key === 'working_hour') {
            let totalMin = parseInt(value);
            let hours = (totalMin/60).toFixed(2) + ' h';
            workingHourInput.value = hours;
          } else if (key === 'max_sonar_distance') {
            document.getElementById('max_sonar_distance').value = value;
          } else if (fields.includes(key)) {
            document.getElementById(key).value = value;
          }
        }
      });
      updateAddressMatchLabel();
      showMsg('Configuration loaded.', 'success');
    }

    document.getElementById('saveBtn').onclick = async () => {
      if (!connected) { showMsg('Not connected.', 'error'); return; }
      try {
        let addr = [];
        for (let i=0; i<5; ++i) addr.push(parseInt(document.getElementById(`address_${i}`).value));
        // Validate max_drive, max_turn, max_cow
        const maxDrive = parseInt(document.getElementById('max_drive').value);
        const maxTurn = parseInt(document.getElementById('max_turn').value);
        const maxCow = parseInt(document.getElementById('max_cow').value);
        // Validate accel, deccel, cow_factor
        const accel = parseFloat(document.getElementById('accel').value);
        const deccel = parseFloat(document.getElementById('deccel').value);
        const cowFactor = parseFloat(document.getElementById('cow_factor').value);
        // New sonar distance value
        const sonar = parseInt(document.getElementById('max_sonar_distance').value);
        let invalidFields = [];
        if (isNaN(maxDrive) || maxDrive < 0 || maxDrive > 1000) invalidFields.push('max_drive');
        if (isNaN(maxTurn) || maxTurn < 0 || maxTurn > 1000) invalidFields.push('max_turn');
        if (isNaN(maxCow) || maxCow < 0 || maxCow > 1000) invalidFields.push('max_cow');
        if (isNaN(accel) || accel < 0 || accel > 1) invalidFields.push('accel');
        if (isNaN(deccel) || deccel < 0 || deccel > 1) invalidFields.push('deccel');
        if (isNaN(cowFactor) || cowFactor < 0 || cowFactor > 1) invalidFields.push('cow_factor');
        if (isNaN(sonar) || sonar < 0 || sonar > 1000) invalidFields.push('max_sonar_distance');
        if (invalidFields.length > 0) {
          let msg = '';
          let rangeMsg = [];
          if (invalidFields.includes('max_drive') || invalidFields.includes('max_turn') || invalidFields.includes('max_cow') || invalidFields.includes('max_sonar_distance')) {
            rangeMsg.push('max_drive, max_turn, max_cow, max_sonar_distance: 280-3000');
          }
          if (invalidFields.includes('accel') || invalidFields.includes('deccel') || invalidFields.includes('cow_factor')) {
            rangeMsg.push('0-1');
          }
          msg = 'Values for ' + invalidFields.join(', ') + ' must be in range: ' + rangeMsg.join('; ');
          showMsg(msg, 'error');
          return;
        }
        await sendCmd(`ADDR=${addr.join(':')}`);
        await sendCmd(`MAX_DRIVE=${maxDrive}`);
        await sendCmd(`MAX_TURN=${maxTurn}`);
        await sendCmd(`MAX_COW=${maxCow}`);
        await sendCmd(`ACCEL=${accel}`);
        await sendCmd(`DECCEL=${deccel}`);
        await sendCmd(`COW_FACTOR=${cowFactor}`);
        await sendCmd(`MAX_SONAR_DISTANCE=${sonar}`);
        await sendCmd(`TIME_OUT=${parseInt(document.getElementById('time_out').value)}`);
        await sendCmd('SAVE');
        showMsg('Configuration saved to STM32 flash.', 'success');
      } catch (e) {
        showMsg('Failed to send/save: ' + e, 'error');
      }
    };

    document.getElementById('loadBtn').onclick = loadFromDevice;

    document.getElementById('resetBtn').onclick = async () => {
      if (!connected) { showMsg('Not connected.', 'error'); return; }
      await sendCmd('RESET');
      showMsg('Device reset command sent.', 'success');
      // Reload values from device after reset
      await loadFromDevice();
    };

    document.getElementById('exportBtn').onclick = () => {
      let data = {};
      fields.forEach(f => { data[f] = document.getElementById(f).value; });
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'stm32_config.json';
      a.click();
      URL.revokeObjectURL(url);
      showMsg('Configuration exported.', 'success');
    };

    document.getElementById('importBtn').onclick = () => {
      document.getElementById('importFile').click();
    };
    document.getElementById('importFile').onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          const data = JSON.parse(ev.target.result);
          fields.forEach(f => {
            if (data[f] !== undefined) document.getElementById(f).value = data[f];
          });
          showMsg('Configuration imported.', 'success');
        } catch (e) {
          showMsg('Failed to import: ' + e, 'error');
        }
      };
      reader.readAsText(file);
    };

    downloadOfflineBtn.onclick = () => {
      // Download only the current HTML file for offline use
      const a = document.createElement('a');
      a.href = window.location.href;
      a.download = 'Cow_USB_Configurator.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    };

    checkUpdateBtn.onclick = async () => {
      // Change this URL to your latest HTML file location (e.g., GitHub raw link)
      const latestUrl = 'https://raw.githubusercontent.com/EmbeddedEra/The_Real_Cow_Configurator/refs/heads/main/index.html';
      const currentVersion = getVersionFromMeta(document);
      showMsg('Checking for update... (Current: ' + currentVersion + ')', '');
      try {
        const response = await fetch(latestUrl, {cache: 'no-store'});
        if (!response.ok) throw new Error('Could not fetch latest version');
        const latestHtml = await response.text();
        // Parse version from fetched HTML
        const parser = new DOMParser();
        const latestDoc = parser.parseFromString(latestHtml, 'text/html');
        const latestVersion = getVersionFromMeta(latestDoc);
        if (!latestVersion) throw new Error('No version found in latest file');
        if (currentVersion === latestVersion) {
          showMsg('You already have the latest version (' + currentVersion + ').', 'success');
          // Do not download if offline and already up to date
          return;
        }
        showMsg('New version available! Current: ' + currentVersion + ', Latest: ' + latestVersion, '');
        // Offer to download if different
        const blob = new Blob([latestHtml], {type: 'text/html'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'Cow_USB_Configurator.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showMsg('Latest version (' + latestVersion + ') downloaded.', 'success');
      } catch (e) {
        showMsg('Could not check for update: ' + e, 'error');
      }
    };

    function getVersionFromMeta(doc) {
      const meta = doc.querySelector('meta[name="cow-configurator-version"]');
      return meta ? meta.getAttribute('content') : '';
    }

    function showMsg(msg, type) {
      msgDiv.textContent = msg;
      msgDiv.className = type;
    }

    // Add this helper function near the top of your <script>
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

    // On load
    window.onload = async () => {
      // Browser check for Web Serial API (best in Chrome/Edge)
      const browserWarning = document.getElementById('browserWarning');
      const isChrome = /Chrome\//.test(navigator.userAgent) && /Google Inc\./.test(navigator.vendor);
      const isEdge = /Edg\//.test(navigator.userAgent);
      if (!isChrome && !isEdge) {
        browserWarning.style.display = '';
        browserWarning.textContent = 'Warning: This app works best in Google Chrome or Microsoft Edge.';
      }
      if (!('serial' in navigator)) {
        showMsg('This app works best in Google Chrome or Microsoft Edge.', 'error');
        connectBtn.disabled = true;
        return;
      }
      // Set all input values to 0 on page load (except working_hour and fixed address bytes)
      const inputFields = [
        'address_3','address_4',
        'max_drive','max_turn','max_cow','accel','deccel','cow_factor','time_out'
      ];
      inputFields.forEach(f => {
        const el = document.getElementById(f);
        if (el) el.value = 0;
      });
      // Set the fixed address values
      document.getElementById('address_0').value = 67;
      document.getElementById('address_1').value = 79;
      document.getElementById('address_2').value = 87;
      const workingHourInput = document.getElementById('working_hour');
      if (workingHourInput) workingHourInput.value = '0.00 h';
      // Show offline label and check update button if running from file:// and hide download button
      if (window.location.protocol === 'file:') {
        offlineLabel.style.display = '';
        downloadOfflineBtn.style.display = 'none';
        checkUpdateBtn.style.display = '';
      }
      // Update version in footer from meta tag
      const versionFooter = document.getElementById('versionFooter');
      const metaVersion = document.querySelector('meta[name="cow-configurator-version"]');
      if (versionFooter && metaVersion) {
        versionFooter.textContent = 'Version: ' + metaVersion.getAttribute('content');
      }
  // Wire presets UI
  wirePresetUI();
    };

    openFlasherBtn.onclick = async () => {
      if (!connected) { showMsg('Not connected.', 'error'); return; }
      try {
        // Re-acquire writer and reader if needed
        if (!writer && port && port.writable) writer = port.writable.getWriter();
        if (!reader && port && port.readable) reader = port.readable.getReader();
        await sendCmd('BOOT_LOADER', false);
        setTimeout(async () => {
          await disconnectSerial();
          window.open('https://embeddedera.github.io/The_Real_Cow_Flasher/', '_blank');
        }, 500); // Give device time to enter bootloader
      } catch (e) {
        showMsg('Failed to send BOOT_LOADER: ' + e, 'error');
      }
    };
  </script>
</body>
</html>
